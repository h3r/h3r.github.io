<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>h3r | Experimento 6</title>
    <link rel="stylesheet" href="style.css"/>
</head>

<body>

    <header><h2>Experimento 6 : Pintar en textura </h2></header>
    <div id="canvas-container" class="full"></div>

<script src="https://code.jquery.com/jquery-1.10.2.js"></script>
<script src="../../js/gl-matrix/gl-matrix-min.js" type="application/javascript"></script>
<script src="../../js/datgui/dat.gui.js" type="application/javascript"></script>
<script src="../../js/litegl/litegl.js" type="application/javascript"></script>
<script src="tools.js"  type="application/javascript"></script>
<script src="gui.js"    type="application/javascript"></script>
<script src="Entity.js" type="application/javascript"></script>
<script src="Camera.js" type="application/javascript"></script>
<script src="ResourceLoader.js"  type="application/javascript"></script>

    <script type="application/javascript">
        "use strict";

        /*litegl experiment 5*/
        var placer = document.getElementById('canvas-container');
        var gl = GL.create({width:placer.clientWidth, height:placer.clientHeight});

        var resources = new ResourceLoader([
            '../../textures/crate.jpg',
            ['../../shaders/s6-toTexture.vs','../../shaders/s6-toTexture.fs'],
            ['../../shaders/phong.vs','../../shaders/phong.fs'],
            ['../../shaders/flat.vs','../../shaders/flat.fs'],

        ],function(){
            placer.appendChild( gl.canvas );
            gl.animate();
            $('canvas').fadeIn("slow");
        },gl);

        var entities = {};

        entities["obj"] = new Entity(false,
            GL.Mesh.plane({size:25}),
            null,
            gl
        );
        var cube = new Entity(false,
                GL.Mesh.cube({size:25}),
                loadTexture('../../textures/crate.jpg',{},null, gl),
                gl
        );

        var model2 = mat4.create();
        var texture = new GL.Texture(512,512, { magFilter: gl.LINEAR });


        entities["grid"] = new Entity(false,
            GL.Mesh.grid({size:200, lines:41}),
            null,
            gl
        );
        entities["grid"].primitive = gl.LINES;

        var camera = new Camera();
        camera.perspective(45 * DEG2RAD, placer.clientWidth / placer.clientHeight, 0.1, 1000);
        camera.lookAt([0,30,30],[0,0,0], [0,1,0]);

        var color = [ 255, 255, 255, 0.99];
        var background = [ 0, 0, 0, 0.99];
        var gamma = 2.2;
        var i_refl = 0.25;
        var speed = 0.5;
        var grid = true;
        var Mode = 2;
        var light = {x:1,y:1,z:1};
        var r = 1/255;

        //basic shader
        var shader = gl.shaders['s6-toTexture'];
        var phong = gl.shaders['phong'];
        var flat = gl.shaders['flat'];

        gl.captureMouse(true);
        gl.onmousedown = function(e) {};

        gl.onmousemove = function (e) {
            if (e.dragging) {
                if (e.leftButton)
                {
                    camera.orbit(vec3.fromValues(e.deltax *  0.005,e.deltay *  0.003, 0) );
                }
                if (e.rightButton)
                {
                    camera.pan(vec3.fromValues(e.deltax * - 0.0325, e.deltay * - 0.0325, 0) );
                }
            }
        };
        gl.onmousewheel = function(e){
            camera.zoom(e.deltaY * 0.01);
        };

        gl.onupdate = function(dt) {
            camera.update();
            mat4.rotateY(entities['obj'].model, entities['obj'].model,dt * speed);
        };


        gl.enable( gl.DEPTH_TEST );


        gl.ondraw = function() {

            texture.drawTo(function(){
                gl.clearColor(0.1,0.3,0.4,1);


                shader.uniforms({
                    u_color:[Math.sin( GL.getTime() * 0.001 ),0.3,0.1,1],
                    u_gamma:        1/gamma,
                    u_texture: cube.tex.bind(1),
                    u_model: cube.getModel(),
                    u_mvp: camera.getMVP(cube.getModel())
                }).draw(cube.mesh,cube.primitive);
            });
            gl.clearColor(0.15,0.15,0.15,1);
            gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

            //compute rotation matrix for normals
            var uniforms = {
                u_texture:      texture.bind(0),
                u_refl:         i_refl,
                u_gamma:        1/gamma,
                u_color:        vec4.multiply(vec4.create(),getColorVec4(color),vec4.fromValues(r,r,r)),
                u_lightvector:  vec3.normalize(vec3.create(),vec4.fromValues(light.x,light.y, light.z))
            };



            //render mesh using the shader
            for(var i in entities){
                if(i == 'grid' && !grid) return;

                if(entities[i].tex != null && Mode == 2){
                    entities[i].tex.bind(0);
                    uniforms.u_has_tex = true;
                }else{uniforms.u_has_tex = false;}


                if(Mode == 2)
                {
                    uniforms.u_model = entities[i].getModel();
                    uniforms.u_mvp   = camera.getMVP(entities[i].getModel());

                    shader
                    .uniforms(uniforms)
                    .draw(entities[i].mesh, entities[i].primitive);
                }
                else{
                    uniforms.u_model = entities[i].getModel();
                    uniforms.u_mvp   = camera.getMVP(entities[i].getModel());

                    phong
                    .uniforms(uniforms)
                    .draw(entities[i].mesh, (Mode == 0 && i != 'grid')?gl.LINES : entities[i].primitive);
                }
                if(entities[i].tex != null && Mode == 2)
                   entities[i].tex.unbind(0);
            }


        };

        /*end litegl experiment 1*/

        /*=============================================
        / Window Resie Handling
        /==============================================*/
        var resize = function() {

            gl.canvas.width   = placer.clientWidth;
            gl.canvas.height  = placer.clientHeight;
            camera.perspective(45 * DEG2RAD, placer.clientWidth / placer.clientHeight, 0.1, 1000);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        };

        window.onresize = resize;

    </script>
</body>
</html>