<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>h3r | Experimento 8</title>
    <link rel="stylesheet" href="style.css"/>
</head>

<body>

    <header><h2>Experimento 8 : Reflexiones avanzadas II</h2></header>
    <div id="canvas-container" class="full"></div>

    <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
    <script src="../../js/gl-matrix/gl-matrix-min.js" type="application/javascript"></script>
    <script src="../../js/datgui/dat.gui.js" type="application/javascript"></script>
    <script src="../../js/litegl/litegl.js" type="application/javascript"></script>
    <script src="tools.js"  type="application/javascript"></script>
    <script src="gui.js"    type="application/javascript"></script>
    <script src="Entity.js" type="application/javascript"></script>
    <script src="Camera.js" type="application/javascript"></script>
    <script src="ResourceLoader.js"  type="application/javascript"></script>
    <script src="ShaderManager.js"  type="application/javascript"></script>

    <script type="application/javascript">
        "use strict";

        /*litegl experiment 8*/
        var placer = document.getElementById('canvas-container');
        var gl = GL.create({width:placer.clientWidth, height:placer.clientHeight});

        var resources = new ResourceLoader([
            '../../textures/crate.jpg',
            ['../../shaders/s6-toTexture.vs','../../shaders/s6-toTexture.fs'],
            ['../../shaders/phong.vs','../../shaders/phong.fs'],
            ['../../shaders/flat.vs','../../shaders/flat.fs'],
            ['../../shaders/new_cubemap.vs','../../shaders/new_cubemap.fs']

        ],function(){
            placer.appendChild( gl.canvas );
            gl.animate();
            $('canvas').fadeIn("slow");
        },gl);

        var entities = {};

        entities["obj"] = new Entity(false,
            GL.Mesh.sphere({size:20}),
            null,
            gl
        );
        entities["obj"].camera = new Camera();
        entities["obj"].camera.perspective(90* DEG2RAD, 1.0, 0.1, 1000);
        entities["obj"].camera.lookAt([0,1,0],[0,1,1], [0,1,0]);


        entities["cube"] = new Entity(false,
                GL.Mesh.cube({size:5}),
                loadTexture('../../textures/crate.jpg',{filter:gl.NEAREST},null, gl),
                gl
        );
        mat4.translate(entities["cube"].model,entities["cube"].model,vec3.fromValues(0,0,37));

        entities["cube1"] = new Entity(false,
                GL.Mesh.cube({size:5}),
                loadTexture('../../textures/crate.jpg',{filter:gl.NEAREST},null, gl),
                gl
        );
        mat4.translate(entities["cube1"].model,entities["cube1"].model,vec3.fromValues(-17,7,17));
        entities["cube2"] = new Entity(false,
                GL.Mesh.cube({size:5}),
                loadTexture('../../textures/crate.jpg',{filter:gl.NEAREST},null, gl),
                gl
        );
        mat4.translate(entities["cube2"].model,entities["cube2"].model,vec3.fromValues(27,0,27));
        entities["cube3"] = new Entity(false,
                GL.Mesh.cube({size:5}),
                loadTexture('../../textures/crate.jpg',{filter:gl.NEAREST},null, gl),
                gl
        );
        mat4.translate(entities["cube3"].model,entities["cube3"].model,vec3.fromValues(0,-5,-57));
        //guardar referencia por nombre

        var texture = new GL.Texture(512,512, { minFilter:gl.NEAREST, magFilter: gl.LINEAR });
        var tex =     new GL.Texture(512,512, { texture_type: gl.TEXTURE_CUBE_MAP, minFilter: gl.NEAREST, magFilter: gl.NEAREST });

        entities["grid"] = new Entity(false,
            GL.Mesh.grid({size:200, lines:41}),
            null,
            gl
        );
        entities["grid"].primitive = gl.LINES;

        var camera = new Camera();
        camera.perspective(45 * DEG2RAD, placer.clientWidth / placer.clientHeight, 0.1, 1000);
        camera.lookAt([0,75,75],[0,1,0], [0,1,0]);

        var color = [ 255, 255, 255, 0.99];
        var background = [ 0, 0, 0, 0.99];
        var gamma = 2.2;
        var i_refl = 0.25;
        var speed = 0.5;
        var grid = true;
        var Mode = 2;
        var light = {x:1,y:1,z:1};
        var r = 1/255;

        //basic shader
        var shader = gl.shaders['s6-toTexture'];
        var phong = gl.shaders['phong'];
        var flat = gl.shaders['flat'];
        var cubemapshader = gl.shaders['new_cubemap'];

        gl.captureMouse(true);
        gl.onmousedown = function(e) {};

        gl.onmousemove = function (e) {
            if (e.dragging) {
                if (e.leftButton)
                {
                    camera.orbit(vec3.fromValues(e.deltax *  0.005,e.deltay *  0.003, 0) );
                }
                if (e.rightButton)
                {
                    camera.pan(vec3.fromValues(e.deltax * - 0.0325, e.deltay * - 0.0325, 0) );
                }
            }
        };
        gl.onmousewheel = function(e){
            camera.zoom(e.deltaY * 0.01);
        };
        var temp = mat4.create();
        gl.onupdate = function(dt) {
            camera.update();

            mat4.rotateX(entities['cube'].model, entities['cube'].model,dt * speed);
            mat4.rotateY(entities['cube'].model, entities['cube'].model,dt * speed);
            mat4.invert(temp,entities['cube'].model);
            mat4.rotateY(temp, temp,dt * speed);
            mat4.invert(entities['cube'].model, temp);

            mat4.rotateX(entities['cube1'].model, entities['cube1'].model,dt * speed);
            mat4.rotateY(entities['cube1'].model, entities['cube1'].model,dt * speed);
            mat4.invert(temp,entities['cube1'].model);
            mat4.rotateY(temp, temp,dt * -speed);
            mat4.invert(entities['cube1'].model, temp);

            mat4.rotateX(entities['cube2'].model, entities['cube2'].model,dt * speed);
            mat4.rotateY(entities['cube2'].model, entities['cube2'].model,dt * speed);
            mat4.invert(temp,entities['cube2'].model);
            mat4.rotateY(temp, temp,dt * -speed);
            mat4.invert(entities['cube2'].model, temp);

            mat4.rotateX(entities['cube3'].model, entities['cube3'].model,dt * speed);
            mat4.rotateY(entities['cube3'].model, entities['cube3'].model,dt * speed);
            mat4.invert(temp,entities['cube3'].model);
            mat4.rotateY(temp, temp,dt * -speed);
            mat4.invert(entities['cube3'].model, temp);
        };

        gl.enable( gl.DEPTH_TEST );

        gl.ondraw = function() {

            //entities['obj'].ref = updateCameraCubemap(entities['obj']);

            gl.clearColor(0.15,0.15,0.15,1);
            gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

            //compute rotation matrix for normals

            var uniforms = {
                u_ref_i:        i_refl || 0.5,
                u_gamma:        1.0/gamma || 2.2,
                u_color:        vec4.multiply(vec4.create(),getColorVec4(color),vec4.fromValues(r,r,r)),
                u_light:        vec3.normalize(vec3.create(),vec4.fromValues(light.x,light.y, light.z))
            };
            var ent = null;
            for(var i in entities){
                if(i == 'grid' && !grid) continue;
                ent = entities[i];
                if(ent.flags & smf.T_SPECULAR){
                    uniforms.u_eye          = camera.getEye();
                    uniforms.u_reflection   = (ent.reflection) ? ent.reflection.bind(2) : 0;
                }
                console.log(ent.flags & smf.T_DIFFUSE);
                if(ent.flags & smf.T_DIFFUSE) {
                    uniforms.u_albedo       = (ent.albedo) ? ent.albedo.bind(1) : 0;
                }
                uniforms.u_model            = ent.getModel();
                uniforms.u_mvp              = camera.getMVP(ent.getModel());

                //cubemapshader.uniforms(uniforms).draw(ent.mesh, ent.primitive);
                ShaderManager.load(ent.flags).uniforms(uniforms).draw(ent.mesh, ent.primitive);
            }
        };

        /*end litegl experiment 1*/

        /*=============================================
        / Window Resie Handling
        /==============================================*/
        var resize = function() {

            gl.canvas.width   = placer.clientWidth;
            gl.canvas.height  = placer.clientHeight;
            camera.perspective(45 * DEG2RAD, placer.clientWidth / placer.clientHeight, 0.1, 1000);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        };

        window.onresize = resize;

    </script>
</body>
</html>