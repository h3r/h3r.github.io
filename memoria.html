<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TFG Hermann Plass</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<link rel="stylesheet" href="https://raw.githubusercontent.com/isagalaev/highlight.js/master/src/styles/monokai_sublime.css" />

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<style>
.pagebreak{page-break-after: always;}
.container{
  width:800px;
  padding:100px;
  background-color:white;
  box-shadow: 0 0 15px black;
}
body{
  background-color:#715D5D;
  padding: 5px;
}
.nav{
  position:fixed;
  top:0;
  left:0;
}
.nav ul{
  list-style-type:none;
  padding:0;
}
.nav ul li{
  background-color: hsla(0, 0%, 37%, 0.23);
  color: white;
  padding: 0.2em 0.5em;
  margin: 4px 0 0 15px;
  border-left: 5px solid #FFDF24;
  box-shadow: 14px -10px 89px;
}
.nav ul li a{
  color: white;
}
</style>
</head>
<body><div class="container"><div id="nav">
<ul>
<li><i class=" icon-left-big"><a href="/">Return</a></i>
</li><li><i class=" icon-up-big"><a href="#index">Index</a></i>
</li></ul>

</div>

<blockquote>
  <p><strong>Nota:</strong> No, no me he matado a hacer una web, es markdown plano auto-publicado, hecho con <a href="https://stackedit.io"><strong>stackedit.io</strong></a></p>
</blockquote>

<h1 id="tfg-physically-based-rendering-over-web-technologies"><strong>TFG</strong>: Physically based rendering over web technologies</h1>



<h6 id="autor"> </h6>



<div class="pagebreak"></div>

<hr>



<h1 id="index">Index</h1>

<p><div class="toc">
<ul>
<li><a href="#tfg-physically-based-rendering-over-web-technologies">TFG: Physically based rendering over web technologies</a><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li><a href="#autor"> </a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#index">Index</a></li>
<li><a href="#1-funcionamiento-del-pipeline">1 Funcionamiento del Pipeline</a><ul>
<li><a href="#11-la-api-opengl">1.1 la API: OpenGL</a></li>
<li><a href="#12-primitive-processing">1.2 Primitive Processing</a></li>
<li><a href="#13-vertex-processing-el-vertex-shader">1.3 Vertex Processing : el vertex shader</a></li>
<li><a href="#14-primitive-assembly">1.4 Primitive Assembly</a></li>
<li><a href="#15-rasterizer">1.5 Rasterizer</a></li>
<li><a href="#16-fragment-shader">1.6 Fragment Shader</a></li>
</ul>
</li>
<li><a href="#n-texturas">N Texturas</a></li>
<li><a href="#enlaces">Enlaces</a></li>
</ul>
</div>
</p>

<hr>

<div class="pagebreak"></div>



<h1 id="1-funcionamiento-del-pipeline">1 <strong>Funcionamiento del Pipeline</strong></h1>

<blockquote>
  <p><img src="http://malideveloper.arm.com/downloads/deved/tutorial/SDK/android/2.0/pipeline.png" alt="Programmable Pipeline" title=""> <br>
  Documentación OpenGL ES<a href="#fn:1docmentacion" id="fnref:1docmentacion" title="See footnote" class="footnote">1</a>
</p></blockquote>



<h2 id="11-la-api-opengl">1.1 la API: <em>OpenGL</em></h2>

<p>No vamos a meternos de pleno, OpenGL es una librería que proporciona una serie de métodos y atributos con los que podemos modificar y definir el funcionamiento de la gpu.</p>

<p>A partir de la versión OpenGL 2.0, se cambia la logica del fixed pipeline y se permite introducir “hacks” para en forma de pequeños programas para modificar el funcionamiento de diferentes fases del pipeline. Pero ya entraremos más adelante con los shaders.</p>

<p>La API nos permite pasar al toda una serie información básica ssobre el modo que se realiza el renderizado como:</p>

<p>Nos permite asignar y subir a la gráfica información básica sobre el modo que se realiza el renderizado</p>

<blockquote>
  <ul>
  <li>La primitiva con la que vamos a interpretar los VertexBuffers</li>
  <li>Arraybuffers con información de los vértices:  el Vertex Buffer <br>
  <ul><li>R<sup>3</sup> :: posición </li>
  <li>R<sup>3</sup> :: vector normal</li>
  <li>R<sup>2</sup> :: coordenadas de textura <em>uv</em></li>
  <li>R<sup>4</sup> :: color rgba</li></ul></li>
  <li>Flags para cambiar ciertos parámetros <br>
  <ul><li><strong><em>Depth Test</em></strong> : habilitar / deshabilitar la oclusión entre objetos de la escena </li>
  <li><strong><em>Alpha Blending</em></strong> : habilitar / deshabilitar la transparencia</li>
  <li><strong><em>Clear Color</em></strong>: establecer el color de fondo con el que vamos a pintar</li></ul></li>
  <li>Mapas de textura de tipo: <br>
  <ul><li><strong>texturas 2D</strong> : texturas normales, shadow maps, bump maps…. Se utiliza un par de coordenadas R<sup>2</sup>::<em>uv</em> para mapear su contenido.</li>
  <li><strong>texturas 3D</strong>: <em>cubemaps</em>, <em>environment maps</em>… Se utiliza un vector  R<sup>3</sup> para mapear su contenido.</li></ul></li>
  </ul>
</blockquote>

<hr>



<h2 id="12-primitive-processing">1.2 Primitive Processing</h2>

<p>Tras haber subido la información relacionada con los objetos en forma de arraybuffers a la memoria <em>gddr</em> de la tarjeta gráfica, se prepara la información para su renderizado.  <br>
Los arraybuffers, en el siguiente ejemplo el vertex buffer, es un array de array que contiene las coordenadas 3D de cada vertice de la malla:</p>



<pre class="prettyprint"><code class="language-javascript hljs ">vertexBuffer = 
[
    [ <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> ],
    [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> ],
    [ <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ],
    [ <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ],
    [ <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span> ],
    [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span> ],
    [ <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span> ],
    [ <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span> ]
]</code></pre>

<blockquote>
  <p><img src="http://www.cores2.com/3D_Tutorial/_images/CubeVertices.png" alt="Vertices en un cubo" title=""></p>
</blockquote>

<p>El modo en que esta información ha de ser interpretada va directamente ligado a la primitiva que hayamos definido:</p>

<ul>
<li><strong>Puntos</strong>: Solo se tiene en cuenta cada vértice individualmente.</li>
<li><strong>Lineas</strong>: Se interpreta la información a pares de vértices, lo cual forma una linea</li>
<li><p><strong>Triangulos</strong>: La primera de las primitivas poligonales, la información se procesa por paquetes de tres vértices, lo cual forma la superficie mínima, cuyos vértices serán siempre coplanares. Tenemos diferentes flags para la misma primitiva:</p>

<ul><li><strong>GL_TRIANGLES</strong>:  Se interpreta el vertex buffer como triángulos independientes,no comparten vértice alguno con ningún otro triángulo.</li>
<li><strong>GL_TRIANGLE_STRIP</strong>: Los triángulos están contectados, los vértices pueden pertenecer a diferentes superficies/triángulos.</li>
<li><p><strong>GL_TRIANGLE_FAN</strong>: El primer vertice define el centro de la geometria y cada par de vertices que añadimos añade un triangulo al objeto.</p>

<blockquote>
  <p><img src="http://black-byte.com/wp-content/uploads/2007/01/triangulos.png" alt="Primitivas" title=""> <br>
  <small>Primitivas en OpenGL ES<a href="#fn:12primitivas" id="fnref:12primitivas" title="See footnote" class="footnote">2</a>
</small></p></blockquote></li></ul></li>
</ul>



<h2 id="13-vertex-processing-el-vertex-shader">1.3 Vertex Processing : el vertex shader</h2>

<p>El Vertex Shader es el primer modulo que vamos a encontrar en el pipeline encargado de definir el comportamiento con el que la gpu tiene que procesar los vértices, en concreto, <strong>definir cuales son las coordenadas de pantalla que el pixel ocupa</strong>.</p>

<p>Su ejecución se realiza exclusivamente una vez por cada vértice que recibe.  La información que tiene disponible se limita a la del vértice que esta siendo procesado (posicion, normal, uv) y las variables que podamos haber cargado desde nuestra CPU denominadas <em>Uniforms</em>.</p>

<p>El prefijo <strong><em>uniform</em></strong> hace referencia a unos datos cargados en memoria que son constantes inalterables durante toda la ejecución del renderizado y, por lo tanto, por cada ejecución del vertex shader por cada vértice que reciba por entrada dispondrá de los mismos valores.</p>

<p>Adicionalmente podemos definir unas variables de salida, una variables denominadas (en esta versión) <strong><em>varyings</em></strong>. El funcionamiento o objetivo de las <em>varyings</em> es pasar información al <strong><em>fragment shader</em></strong>. El valor obtenido en el <em>fragment shader</em> es el resultado de la interpretación lineal entre los diferentes vértices de la primitiva procesada.   Las <em>varyings</em> pueden ser de tipo <strong>float, vec2, vec3, vec4, mat2, mat3, mat4</strong> y arrays de los respectivos. </p>

<p>Un uso muy común de las varyings suele ser para definir el color que recibirá un pixel.</p>

<blockquote>
  <p><img src="http://3.bp.blogspot.com/-kgKg2kiBvD0/TarT8eoeV9I/AAAAAAAAAaI/-P36pCTG56s/s1600/BilinearGradient.png" alt="Interpolacion lineal de color" title=""> <br>
  <small>Interpolacion lineal del color definido en cada vértice del cuad.</small></p>
</blockquote>

<hr>



<h2 id="14-primitive-assembly">1.4 Primitive Assembly</h2>

<hr>



<h2 id="15-rasterizer">1.5 Rasterizer</h2>

<p>Entendemos por Raserizado 3D como el método que permite proyectar y pintar sobre un plano 2D( la pantalla ) un modelo 3D.</p>

<p>La primera fase del rasterizado se trata en proyectar las coordenadas 3D de cada vértice en el plano 2D de la pantalla. Para ello hacemos uso de una serie de matrices de cambio de base, en concreto queremos transformar los ejes de coordenadas del espacio global a un eje de coordenadas de cámara, donde el front de la cámara define la profundidad y el top y el right el eje de ordenadas y abscisas respectivamente. Es importante esta transformación ya que nos permitirá almacenar la profundidad de cada punto en el espacio, obteniendo el Z-Buffer que posteriormente podemos utilizar para detectar oclusiones (que objeto queda ocluido por la presencia de otro).</p>

<p>El segundo paso se trata de traducir estas coordenadas de cámara a un plano 2D de un tamaño fijo que es nuestra pantalla, alineada con los ejes de ordenadas y abscisas de la cámara. Para ello recorreremos secuencialmente vértice de cada cara de cada objeto de la escena y los pintaremos en pantalla. Además guardaremos la coordenada z del vértice y lo almacenaremos en un buffer que tiene el mismo tamaño de la pantalla que estamos pintando y registramos ,a profundidad con valor entre 0 y 1. Usualmente el 0 hace referencia a la distancia a la que se encuentra el near plane (el plano más cercano que limita el espacio que renderizamos) y el 1 a la distancia del far plane (el plano más alejado).</p>

<p>Tras haber situado la posición en pantalla de cada vértice, se procede a pintar las aristas.</p>

<p>Para pintar un punto de la arista lo que lo que vamos a hacer es calcular la pendiente de la recta que une los dos pixeles correspondientes a los vértices. Tras saber la posición que corresponde al nuevo punto de la arista consultamos primero el Z-buffer, si el valor de profundidad es más pequeño que el valor registrado en el Z-buffer el pixel se ve, sino este queda oculto y permanece el color ya existente. <br>
Una vez terminado de pintar las aristas pasamos a pintar el interior de la geometría. Vamos a ir fila a fila y pintaremos todo aquello que este entre pares de pixeles ya pintados.</p>

<blockquote>
  <p><img src="http://www.codeproject.com/KB/GDI/3DSoftwareRenderingEngine/scanlinerasterizer.png" alt="" title=""></p>
</blockquote>

<p>Una vez que sabemos si podemos pintar o no un pixel, el fixed pipeline de la tarjeta gráfica nos permite escoger un modelo de iluminación local para obtener el color final que corresponde al píxel.</p>

<hr>



<h2 id="16-fragment-shader">1.6 Fragment Shader</h2>



<h1 id="n-texturas">N Texturas</h1>

<div class="pagebreak"></div>

<!-- anexos -->

<hr>



<h1 id="enlaces">Enlaces</h1>

<div class="footnotes"><hr><ol><li id="fn:1docmentacion">Documentación OpenGL ES @ <a href="https://www.khronos.org/registry/gles/specs/2.0/es_cm_spec_2.0.24.pdf"><strong>kronos.org</strong></a> <a href="#fnref:1docmentacion" title="Return to article" class="reversefootnote">↩</a></li><li id="fn:12primitivas">Primitivas en OpenGL ES@ <a href="http://black-byte.com/tutorial/primitivas-en-opengl/"><strong>Black-Byte</strong></a> <a href="#fnref:12primitivas" title="Return to article" class="reversefootnote">↩</a></li></ol></div></div></body>
</html>
